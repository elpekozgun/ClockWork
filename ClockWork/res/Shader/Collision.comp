#version 450 core

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;


struct Box
{
	vec3 Min;
	uint Id;
	vec3 Max;
};

struct Collision
{
	vec3 Point;
	uint Id1;
	vec3 Normal;
	uint Id2;
};


layout(std430, binding = 1) buffer BoxBuffer1 
{
	Box boxes1[];
};

layout(std430, binding = 2) buffer BoxBuffer2
{
	Box boxes2[];
};

layout(std430, binding = 3) buffer CollisionBuffer
{
	Collision Collisions[];
};

layout(binding = 4) uniform atomic_uint Counter;




vec3 GetPenetration(Box box1, Box box2);

void BoxVsBox()
{
	uint gid = gl_GlobalInvocationID.x;

	if(gid >= boxes1.length() * boxes2.length())
		return;

	uint i = gid / boxes2.length();
	uint j = gid % boxes2.length();

	if(i >= j)
		return;

	Box box1 = boxes1[i];
	Box box2 = boxes2[j];

	if(box1.Id == box2.Id)
		return;

	vec3 collisionPoint;

	bool intersect = true;
	float SeparationDistance = 0.02;
	
	vec3 penetration;

	float minPenetration = 200000000;
	int minAxis = -1;

	for(int k = 0; k < 3; k++)
	{
		if(box1.Max[k] < box2.Min[k] || box1.Min[k] > box2.Max[k])
		{
			intersect = false;
			break;
		}
	}

	if(intersect)
	{
		uint index = atomicCounterIncrement(Counter);
		penetration = GetPenetration(box1, box2);

		Collision collision;
		collision.Point = penetration;
		collision.Id1 = box1.Id;
		collision.Id2 = box2.Id;
		collision.Normal = vec3(0,1,0);

		Collisions[index] = collision;
	}
    memoryBarrierBuffer();
}

vec3 GetPenetration(Box box1, Box box2)
{
	vec3 penetration;
	
	float minPenetration = 200000000;
	int minAxis = -1;
	for(int i = 0 ; i < 3; i++)
	{
		float penetrationDepth = min(box1.Max[i] - box2.Min[i], box2.Max[i] - box1.Min[i]);
		if(penetrationDepth < minPenetration)
		{
			minPenetration = penetrationDepth;
			minAxis = i;
		}
	}

	if(minAxis >= 0)
		penetration[minAxis] = minPenetration;

	return penetration;
}



void BoxVsPlane()
{

}

void main()
{
	BoxVsBox();
}

